250922
我想提高插件的泛用性。
1.增加一个保存与复原待执行图层状态逻辑：假如用户选择待执行图层是锁定的或隐藏的，先记录它的状态，然后再转化为显示并且解锁的状态，这以后再对正常化的待执行图层执行复制滤镜。复制完，在栅格化后，恢复它原先的状态。

2.增加蒙版保护的逻辑：假设某个待执行图层有图层蒙版，则转化为智能对象，随后栅格化这一系列操作会导致其蒙版丢失。
为了避免丢失蒙版，对于这带蒙版的图层，我们需要保护蒙版的机制：为每个带蒙版的图层新建一个临时图层，做好标记，把它们的图层蒙版通过应用图层功能转为黑白的像素图层。
等到原图层复制完滤镜，被栅格化后。是没有蒙版的，我们需要为它们新建空白蒙版，再通过应用图层把临时图层中的信息应用到新的空白蒙版上，最后删掉临时图层。

3.增加蒙版的液化逻辑：
在目标2的基础上，假如待执行图层不仅有蒙版，而且智能滤镜中还存在有液化这个滤镜，我们还需要增加一个逻辑：
对于这种情况，液化不仅需要作用于带蒙版图层的像素部分，还需要作用于它们的蒙版。
为了实现这个目标，我们需要通过应用图像功能，把蒙版中的信息转为黑白像素图层。对于蒙版转化的这个临时图层，我们需要额外单独复制液化智能滤镜给它，其他智能滤镜则不需要复制！
这样我们就可以得到液化后的图层。然后我们只需要将这个液化后的图层通过应用图层给原图层蒙版，就能实现液化蒙版的效果。
最后需要删掉临时图层。

应用图像的参考代码，仅为格式参考，***指代变量。
将蒙版信息给临时图层：先选中图层，再应用图像。
{
    "_obj": "select",
    "_target": [{
        "_ref": "layer",
        "_name": "存放***蒙版信息临时图层"
    }],
    "makeVisible": false,
    "layerID": [***],
    "_isCommand": false
}

{
    "_obj": "applyImageEvent",
    "with": {
        "_obj": "calculation",
        "to": {
            "_ref": [{
                "_ref": "channel",
                "_enum": "channel",
                "_value": "mask"
            },
            {
                "_ref": "layer",
                "_name": "***"
            }]
        }
    },
    "_isCommand": false
}

将液化后的图层信息给蒙版：先新建空白蒙版，再应用图像。
{
    _obj: 'make',
    new: { _class: 'channel' },
    at: { 
        _ref: 'channel',
        _enum: 'channel',
        _value: 'mask'
    },
    using: {
        _enum: 'userMaskEnabled',
        _value: 'revealAll'
    },
    _isCommand: false,
}

{
    "_obj": "applyImageEvent",
    "with": {
        "_obj": "calculation",
        "to": {
            "_ref": [{
                "_ref": "channel",
                "_enum": "channel",
                "_value": "RGB"
            },
            {
                "_ref": "layer",
                "_name": "存放***蒙版信息的临时图层"
            }]
        },
        "preserveTransparency": true
    },
    "_isCommand": false
}
